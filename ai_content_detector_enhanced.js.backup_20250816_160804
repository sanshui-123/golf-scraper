#!/usr/bin/env node

/**
 * 增强版AI文本检测模块
 * 支持比特浏览器和智能代理两种模式
 * 使用腾讯AI检测平台检测文章内容的AI生成概率
 */

const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');
const SmartProxyManager = require('./smart_proxy_manager');
const BitBrowserManager = require('./bitbrowser_manager');

class EnhancedAIContentDetector {
    constructor() {
        this.detectionUrl = 'https://matrix.tencent.com/ai-detect/';
        this.cache = new Map(); // 缓存检测结果
        this.maxRetries = 3;
        this.timeout = 30000; // 30秒超时
        
        // 检测模式：'bitbrowser' | 'proxy' | 'hybrid'
        this.detectionMode = 'hybrid'; // 默认混合模式
        
        // 管理器实例
        this.proxyManager = null;
        this.bitBrowserManager = null;
        
        // 当前使用的模式统计
        this.modeStats = {
            bitbrowser: { attempts: 0, success: 0 },
            proxy: { attempts: 0, success: 0 }
        };
        
        // 调试模式
        this.debug = process.env.AI_DETECTOR_DEBUG === 'true';
    }
    
    /**
     * 初始化检测器
     */
    async initialize() {
        try {
            console.log('🚀 初始化增强版AI检测器...');
            
            // 尝试初始化比特浏览器
            if (this.detectionMode === 'bitbrowser' || this.detectionMode === 'hybrid') {
                try {
                    this.bitBrowserManager = new BitBrowserManager();
                    await this.bitBrowserManager.initialize();
                    console.log('✅ 比特浏览器初始化成功');
                } catch (error) {
                    console.warn('⚠️ 比特浏览器初始化失败，将使用代理模式:', error.message);
                    if (this.detectionMode === 'bitbrowser') {
                        this.detectionMode = 'proxy';
                    }
                }
            }
            
            // 初始化代理管理器
            if (this.detectionMode === 'proxy' || this.detectionMode === 'hybrid') {
                this.proxyManager = new SmartProxyManager();
                await this.proxyManager.initialize();
                console.log('✅ 智能代理管理器初始化成功');
            }
            
            console.log(`🎯 检测模式: ${this.detectionMode}`);
            
        } catch (error) {
            console.error('❌ AI检测器初始化失败:', error.message);
            throw error;
        }
    }
    
    /**
     * 检测文本的AI概率
     * @param {string} text - 要检测的文本内容
     * @returns {Promise<number|null>} - AI概率(0-100)或null(失败时)
     */
    async detectText(text) {
        if (!text || text.length < 10) {
            console.log('⚠️ 文本内容太短，跳过检测');
            return null;
        }
        
        // 检查缓存
        const textHash = this.hashText(text);
        if (this.cache.has(textHash)) {
            console.log('📦 使用缓存的检测结果');
            return this.cache.get(textHash);
        }
        
        let result = null;
        
        // 根据模式选择检测方法
        switch (this.detectionMode) {
            case 'bitbrowser':
                result = await this.detectWithBitBrowser(text);
                break;
                
            case 'proxy':
                result = await this.detectWithProxy(text);
                break;
                
            case 'hybrid':
                // 优先使用比特浏览器
                if (this.bitBrowserManager) {
                    result = await this.detectWithBitBrowser(text);
                }
                // 如果比特浏览器失败，降级到代理模式
                if (result === null && this.proxyManager) {
                    console.log('🔄 比特浏览器失败，切换到代理模式');
                    result = await this.detectWithProxy(text);
                }
                break;
        }
        
        // 缓存成功的结果
        if (result !== null) {
            this.cache.set(textHash, result);
        }
        
        return result;
    }
    
    /**
     * 使用比特浏览器检测
     * @param {string} text - 要检测的文本
     * @returns {Promise<number|null>} - AI概率或null
     */
    async detectWithBitBrowser(text) {
        console.log('🌐 使用比特浏览器模式检测');
        this.modeStats.bitbrowser.attempts++;
        
        let browser = null;
        let context = null;
        let currentProfile = null;
        
        try {
            // 获取最优配置文件
            currentProfile = await this.bitBrowserManager.getOptimalProfile();
            if (!currentProfile) {
                console.error('❌ 没有可用的浏览器配置文件');
                return null;
            }
            
            // 启动浏览器
            const browserInfo = await this.bitBrowserManager.launchBrowser(currentProfile.id);
            
            // 连接Playwright
            const connection = await this.bitBrowserManager.connectBrowser(browserInfo.wsEndpoint);
            browser = connection.browser;
            context = connection.context;
            
            console.log(`📍 使用配置: ${currentProfile.name} (IP: ${browserInfo.ip || '未知'})`);
            
            // 执行检测
            const result = await this._performDetection(context, text);
            
            if (result !== null) {
                // 记录成功
                await this.bitBrowserManager.recordUsage(currentProfile.id, true);
                this.modeStats.bitbrowser.success++;
                console.log(`✅ 比特浏览器检测成功: ${result}%`);
            } else {
                // 记录失败
                await this.bitBrowserManager.recordUsage(currentProfile.id, false);
            }
            
            return result;
            
        } catch (error) {
            console.error('❌ 比特浏览器检测失败:', error.message);
            
            if (currentProfile) {
                await this.bitBrowserManager.recordUsage(currentProfile.id, false);
            }
            
            return null;
            
        } finally {
            // 清理资源
            try {
                if (browser) {
                    await browser.close();
                }
                if (currentProfile) {
                    await this.bitBrowserManager.closeBrowser(currentProfile.id);
                }
            } catch (error) {
                console.error('⚠️ 清理资源失败:', error.message);
            }
        }
    }
    
    /**
     * 使用代理模式检测
     * @param {string} text - 要检测的文本
     * @returns {Promise<number|null>} - AI概率或null
     */
    async detectWithProxy(text) {
        console.log('🔄 使用智能代理模式检测');
        this.modeStats.proxy.attempts++;
        
        let browser = null;
        let context = null;
        let currentProxy = null;
        const startTime = Date.now();
        
        try {
            // 获取最优代理
            currentProxy = await this.proxyManager.getOptimalProxy();
            if (!currentProxy) {
                console.error('❌ 没有可用的代理');
                return null;
            }
            
            // 创建浏览器实例
            const launchOptions = {
                headless: true,
                args: ['--no-sandbox', '--disable-setuid-sandbox']
            };
            
            if (currentProxy.type !== 'direct') {
                launchOptions.proxy = this.proxyManager.getPlaywrightProxyConfig(currentProxy);
                console.log(`🌐 使用代理: ${currentProxy.name || this.proxyManager.getProxyKey(currentProxy)}`);
            }
            
            browser = await chromium.launch(launchOptions);
            context = await browser.newContext({
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            });
            
            // 执行检测
            const result = await this._performDetection(context, text);
            const responseTime = Date.now() - startTime;
            
            if (result !== null) {
                // 记录成功
                await this.proxyManager.recordProxyUsage(currentProxy, true, responseTime);
                this.modeStats.proxy.success++;
                console.log(`✅ 代理检测成功: ${result}%`);
            } else {
                // 记录失败
                await this.proxyManager.recordProxyUsage(currentProxy, false, responseTime, 'DETECTION_FAILED');
            }
            
            return result;
            
        } catch (error) {
            console.error('❌ 代理检测失败:', error.message);
            
            if (currentProxy) {
                const errorType = this.proxyManager.categorizeError(error);
                const responseTime = Date.now() - startTime;
                await this.proxyManager.recordProxyUsage(currentProxy, false, responseTime, errorType);
            }
            
            return null;
            
        } finally {
            // 清理资源
            if (browser) {
                await browser.close();
            }
        }
    }
    
    /**
     * 执行实际的检测操作
     * @param {Object} context - 浏览器上下文
     * @param {string} text - 要检测的文本
     * @returns {Promise<number|null>} - AI概率或null
     */
    async _performDetection(context, text) {
        const page = await context.newPage();
        let screenshotCount = 0;
        const debugDir = path.join(__dirname, 'ai_detection_debug');
        
        // 创建调试目录
        if (this.debug) {
            try {
                await fs.mkdir(debugDir, { recursive: true });
            } catch (e) {}
        }
        
        try {
            // 设置页面超时
            page.setDefaultTimeout(this.timeout);
            
            // 访问检测页面
            console.log('   📍 访问AI检测页面...');
            const response = await page.goto(this.detectionUrl, { 
                waitUntil: 'networkidle',
                timeout: this.timeout 
            });
            
            // 检查页面是否正常加载
            if (!response || response.status() !== 200) {
                console.warn(`   ⚠️ 页面加载异常: ${response ? response.status() : '无响应'}`);
                
                // 演示模式：如果无法访问真实检测页面，返回模拟结果
                if (process.env.AI_DETECTOR_DEMO === 'true') {
                    console.log('   🎭 使用演示模式...');
                    const demoResult = Math.floor(Math.random() * 40) + 10; // 10-50%的随机值
                    console.log(`   📊 演示检测结果: ${demoResult}%`);
                    return demoResult;
                }
            }
            
            // 等待页面完全加载
            console.log('   ⏳ 等待页面加载...');
            await page.waitForTimeout(3000);
            
            // 截图1：页面加载后
            if (this.debug) {
                const screenshotPath = path.join(debugDir, `step1_loaded_${Date.now()}.png`);
                await page.screenshot({ path: screenshotPath, fullPage: true });
                console.log(`   📸 已截图: ${screenshotPath}`);
            }
            
            // 尝试多种输入框选择器
            console.log('   🔍 查找输入框...');
            const textareaSelectors = [
                // 通用选择器
                'textarea',
                'textarea[placeholder*="输入"]',
                'textarea[placeholder*="文本"]',
                'textarea[placeholder*="内容"]',
                'textarea[placeholder*="请输入"]',
                // 框架特定选择器
                '.el-textarea__inner',
                '.el-textarea textarea',
                '.ant-input',
                '.ant-input-textarea textarea',
                // 富文本编辑器
                '[contenteditable="true"]',
                '[role="textbox"]',
                'div[contenteditable="true"]',
                // 更具体的选择器
                '#text-input',
                '#ai-detect-input',
                '.ai-detect-textarea',
                '.detection-input'
            ];
            
            let inputElement = null;
            let inputSelector = null;
            
            // 等待输入框出现
            for (const selector of textareaSelectors) {
                try {
                    await page.waitForSelector(selector, { timeout: 5000 });
                    const element = await page.locator(selector).first();
                    if (await element.isVisible()) {
                        inputElement = element;
                        inputSelector = selector;
                        console.log(`   ✅ 找到输入框: ${selector}`);
                        break;
                    }
                } catch (e) {
                    // 继续尝试下一个选择器
                }
            }
            
            if (!inputElement) {
                // 如果还是找不到，尝试通过其他方式查找
                console.log('   🔍 尝试其他方式查找输入框...');
                
                // 查找所有可能的输入元素
                const allInputs = await page.evaluate(() => {
                    const inputs = [];
                    // 查找所有textarea
                    document.querySelectorAll('textarea').forEach((el, index) => {
                        inputs.push({
                            type: 'textarea',
                            index: index,
                            visible: el.offsetParent !== null,
                            placeholder: el.placeholder,
                            className: el.className
                        });
                    });
                    // 查找所有contenteditable
                    document.querySelectorAll('[contenteditable="true"]').forEach((el, index) => {
                        inputs.push({
                            type: 'contenteditable',
                            index: index,
                            visible: el.offsetParent !== null,
                            className: el.className
                        });
                    });
                    return inputs;
                });
                
                console.log(`   📋 找到的输入元素: ${JSON.stringify(allInputs, null, 2)}`);
                
                if (this.debug) {
                    const screenshotPath = path.join(debugDir, `step1_5_no_input_found_${Date.now()}.png`);
                    await page.screenshot({ path: screenshotPath, fullPage: true });
                    console.log(`   📸 调试截图: ${screenshotPath}`);
                }
                
                throw new Error('未找到输入框');
            }
            
            // 清空并输入文本
            console.log('   ✏️ 输入文本...');
            
            // 根据元素类型选择输入方式
            if (inputSelector && inputSelector.includes('contenteditable')) {
                // 对于contenteditable元素
                await inputElement.click();
                await page.keyboard.press('Control+A');
                await page.keyboard.press('Delete');
                await inputElement.type(text);
            } else {
                // 对于普通输入框
                await inputElement.click();
                await inputElement.fill('');
                await inputElement.fill(text);
            }
            
            await page.waitForTimeout(1500);
            
            // 截图2：输入文本后
            if (this.debug) {
                const screenshotPath = path.join(debugDir, `step2_text_input_${Date.now()}.png`);
                await page.screenshot({ path: screenshotPath, fullPage: true });
                console.log(`   📸 已截图: ${screenshotPath}`);
            }
            
            // 查找并点击检测按钮
            console.log('   🔍 查找检测按钮...');
            const buttonSelectors = [
                // 文本匹配
                'button:has-text("检测")',
                'button:has-text("开始检测")',
                'button:has-text("AI检测")',
                'button:has-text("开始")',
                'button:has-text("提交")',
                'button:has-text("立即检测")',
                // 类名匹配
                '.submit-btn',
                '.detect-btn',
                '.detection-btn',
                '.ai-detect-btn',
                // 通用按钮
                'button[type="submit"]',
                'button.el-button',
                'button.el-button--primary',
                'button.ant-btn',
                'button.ant-btn-primary',
                // ID匹配
                '#detect-btn',
                '#submit-btn',
                // 其他可能的按钮
                'a:has-text("检测")',
                'span:has-text("检测")',
                'div[role="button"]:has-text("检测")'
            ];
            
            let detectButton = null;
            let buttonSelector = null;
            
            for (const selector of buttonSelectors) {
                try {
                    const button = await page.locator(selector).first();
                    if (await button.isVisible()) {
                        detectButton = button;
                        buttonSelector = selector;
                        console.log(`   ✅ 找到检测按钮: ${selector}`);
                        break;
                    }
                } catch (e) {
                    continue;
                }
            }
            
            if (!detectButton) {
                // 尝试通过evaluate查找按钮
                console.log('   🔍 尝试其他方式查找按钮...');
                
                const allButtons = await page.evaluate(() => {
                    const buttons = [];
                    document.querySelectorAll('button, a, div[role="button"]').forEach((el, index) => {
                        const text = el.textContent || '';
                        if (text.includes('检测') || text.includes('开始') || text.includes('提交')) {
                            buttons.push({
                                tag: el.tagName,
                                text: text.trim(),
                                className: el.className,
                                visible: el.offsetParent !== null
                            });
                        }
                    });
                    return buttons;
                });
                
                console.log(`   📋 找到的按钮: ${JSON.stringify(allButtons, null, 2)}`);
                
                if (this.debug) {
                    const screenshotPath = path.join(debugDir, `step2_5_no_button_found_${Date.now()}.png`);
                    await page.screenshot({ path: screenshotPath, fullPage: true });
                    console.log(`   📸 调试截图: ${screenshotPath}`);
                }
                
                throw new Error('未找到检测按钮');
            }
            
            console.log('   🖱️ 点击检测按钮...');
            await detectButton.click();
            
            // 等待结果显示
            console.log('   ⏳ 等待检测结果...');
            
            // 等待可能的加载动画消失
            try {
                await page.waitForSelector('.loading', { state: 'hidden', timeout: 10000 });
            } catch (e) {
                // 忽略，可能没有加载动画
            }
            
            await page.waitForTimeout(5000);
            
            // 截图3：检测结果
            if (this.debug) {
                const screenshotPath = path.join(debugDir, `step3_result_${Date.now()}.png`);
                await page.screenshot({ path: screenshotPath, fullPage: true });
                console.log(`   📸 已截图: ${screenshotPath}`);
            }
            
            // 尝试多种可能的结果选择器
            console.log('   🔍 查找检测结果...');
            const resultSelectors = [
                // 具体的结果选择器
                '.result-percentage',
                '.ai-probability',
                '.detection-result',
                '.ai-detection-result',
                // 类名包含关键词
                '[class*="result"]',
                '[class*="probability"]',
                '[class*="percent"]',
                '[class*="score"]',
                '[class*="rate"]',
                // 弹窗和模态框
                '.el-dialog',
                '.el-dialog__body',
                '.ant-modal',
                '.ant-modal-body',
                '.modal-content',
                // 数据属性
                '[data-testid*="result"]',
                '[data-role*="result"]',
                // 文本内容包含百分号
                'span:has-text("%")',
                'div:has-text("%")',
                'p:has-text("%")',
                'strong:has-text("%")',
                'b:has-text("%")',
                // 特定的结果区域
                '.result-container',
                '.detection-output',
                '#detection-result'
            ];
            
            let aiProbability = null;
            
            // 首先尝试等待结果出现
            try {
                await page.waitForFunction(() => {
                    return document.body.innerText.includes('%');
                }, { timeout: 10000 });
            } catch (e) {
                console.log('   ⚠️ 未检测到百分号');
            }
            
            // 尝试各种选择器
            for (const selector of resultSelectors) {
                try {
                    const elements = await page.locator(selector).all();
                    for (const element of elements) {
                        if (await element.isVisible()) {
                            const text = await element.textContent();
                            // 更宽松的匹配模式
                            const matches = text.match(/(\d+(?:\.\d+)?)\s*%/g);
                            if (matches) {
                                // 如果有多个百分比，选择第一个合理的值
                                for (const match of matches) {
                                    const value = parseFloat(match);
                                    if (value >= 0 && value <= 100) {
                                        aiProbability = value;
                                        console.log(`   ✅ 找到检测结果: ${aiProbability}% (来自: ${selector})`);
                                        break;
                                    }
                                }
                            }
                        }
                        if (aiProbability !== null) break;
                    }
                    if (aiProbability !== null) break;
                } catch (e) {
                    continue;
                }
            }
            
            // 如果还是没找到，尝试从整个页面文本中提取
            if (aiProbability === null) {
                console.log('   🔍 尝试从页面文本中提取结果...');
                
                const pageText = await page.evaluate(() => document.body.innerText);
                const allMatches = pageText.match(/(\d+(?:\.\d+)?)\s*%/g);
                
                if (allMatches) {
                    console.log(`   📋 页面中找到的所有百分比: ${allMatches.join(', ')}`);
                    
                    // 选择一个合理的值（通常是第一个0-100之间的值）
                    for (const match of allMatches) {
                        const value = parseFloat(match);
                        if (value >= 0 && value <= 100) {
                            aiProbability = value;
                            console.log(`   ✅ 从页面文本提取结果: ${aiProbability}%`);
                            break;
                        }
                    }
                }
            }
            
            // 最终调试截图
            if (aiProbability === null) {
                console.warn('   ⚠️ 未找到检测结果，保存调试信息');
                
                const debugInfo = {
                    url: page.url(),
                    title: await page.title(),
                    bodyText: await page.evaluate(() => document.body.innerText.substring(0, 1000)),
                    timestamp: new Date().toISOString()
                };
                
                const debugPath = path.join(debugDir, `debug_info_${Date.now()}.json`);
                await fs.writeFile(debugPath, JSON.stringify(debugInfo, null, 2));
                console.log(`   📝 调试信息已保存: ${debugPath}`);
                
                const screenshotPath = path.join(debugDir, `final_debug_${Date.now()}.png`);
                await page.screenshot({ path: screenshotPath, fullPage: true });
                console.log(`   📸 最终调试截图: ${screenshotPath}`);
            }
            
            return aiProbability;
            
        } catch (error) {
            console.error('   ❌ 检测过程出错:', error.message);
            
            if (this.debug) {
                const screenshotPath = path.join(debugDir, `error_${Date.now()}.png`);
                try {
                    await page.screenshot({ path: screenshotPath, fullPage: true });
                    console.log(`   📸 错误截图: ${screenshotPath}`);
                } catch (e) {}
            }
            
            return null;
        } finally {
            await page.close();
        }
    }
    
    /**
     * 批量检测
     * @param {Array<Object>} items - 待检测项目列表 [{id, text}]
     * @returns {Array<Object>} - 检测结果列表 [{id, probability}]
     */
    async batchDetect(items) {
        console.log(`📋 开始批量检测 ${items.length} 个项目`);
        const results = [];
        
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            console.log(`\n[${i + 1}/${items.length}] 检测项目: ${item.id}`);
            
            const probability = await this.detectText(item.text);
            results.push({
                id: item.id,
                probability: probability,
                timestamp: new Date().toISOString()
            });
            
            // 批量检测间隔，避免过于频繁
            if (i < items.length - 1) {
                await this.sleep(2000);
            }
        }
        
        // 显示统计信息
        this.showStatistics();
        
        return results;
    }
    
    /**
     * 显示统计信息
     */
    showStatistics() {
        console.log('\n📊 检测统计:');
        console.log('比特浏览器模式:');
        console.log(`  尝试: ${this.modeStats.bitbrowser.attempts}`);
        console.log(`  成功: ${this.modeStats.bitbrowser.success}`);
        console.log(`  成功率: ${this.modeStats.bitbrowser.attempts > 0 ? 
            (this.modeStats.bitbrowser.success / this.modeStats.bitbrowser.attempts * 100).toFixed(1) : 0}%`);
        
        console.log('智能代理模式:');
        console.log(`  尝试: ${this.modeStats.proxy.attempts}`);
        console.log(`  成功: ${this.modeStats.proxy.success}`);
        console.log(`  成功率: ${this.modeStats.proxy.attempts > 0 ? 
            (this.modeStats.proxy.success / this.modeStats.proxy.attempts * 100).toFixed(1) : 0}%`);
    }
    
    /**
     * 设置检测模式
     * @param {string} mode - 'bitbrowser' | 'proxy' | 'hybrid'
     */
    setDetectionMode(mode) {
        if (['bitbrowser', 'proxy', 'hybrid'].includes(mode)) {
            this.detectionMode = mode;
            console.log(`🎯 检测模式已设置为: ${mode}`);
        } else {
            console.error('❌ 无效的检测模式');
        }
    }
    
    /**
     * 计算文本哈希值
     */
    hashText(text) {
        const crypto = require('crypto');
        return crypto.createHash('md5').update(text).digest('hex');
    }
    
    /**
     * 延迟函数
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * 清理资源
     */
    async cleanup() {
        if (this.bitBrowserManager) {
            await this.bitBrowserManager.cleanup();
        }
        if (this.proxyManager) {
            await this.proxyManager.cleanup();
        }
        console.log('🧹 AI检测器已清理');
    }
}

// 导出模块
module.exports = EnhancedAIContentDetector;

// 命令行支持
if (require.main === module) {
    const args = process.argv.slice(2);
    
    (async () => {
        const detector = new EnhancedAIContentDetector();
        
        try {
            // 处理模式参数
            if (args.includes('--mode')) {
                const modeIndex = args.indexOf('--mode');
                if (modeIndex !== -1 && args[modeIndex + 1]) {
                    detector.setDetectionMode(args[modeIndex + 1]);
                }
            }
            
            await detector.initialize();
            
            if (args[0] === '--file' && args[1]) {
                // 检测文件
                const filePath = args[1];
                const content = await fs.readFile(filePath, 'utf8');
                
                // 提取文章正文（去除元数据）
                const bodyMatch = content.match(/---[\s\S]*?---\s*([\s\S]*)/);
                const text = bodyMatch ? bodyMatch[1] : content;
                
                console.log(`\n📄 检测文件: ${filePath}`);
                const probability = await detector.detectText(text);
                
                if (probability !== null) {
                    console.log(`\n🤖 AI生成概率: ${probability}%`);
                } else {
                    console.log('\n❌ 检测失败');
                }
                
            } else if (args[0] === '--batch' && args[1]) {
                // 批量检测目录
                const dirPath = args[1];
                const files = await fs.readdir(dirPath);
                const mdFiles = files.filter(f => f.endsWith('.md'));
                
                const items = [];
                for (const file of mdFiles) {
                    const filePath = path.join(dirPath, file);
                    const content = await fs.readFile(filePath, 'utf8');
                    const bodyMatch = content.match(/---[\s\S]*?---\s*([\s\S]*)/);
                    const text = bodyMatch ? bodyMatch[1] : content;
                    
                    items.push({ id: file, text });
                }
                
                const results = await detector.batchDetect(items);
                
                console.log('\n📊 批量检测结果:');
                results.forEach(result => {
                    console.log(`${result.id}: ${result.probability !== null ? result.probability + '%' : '失败'}`);
                });
                
            } else if (args.length > 0 && !args[0].startsWith('--')) {
                // 直接检测文本
                const text = args.join(' ');
                console.log('\n📝 检测文本内容...');
                const probability = await detector.detectText(text);
                
                if (probability !== null) {
                    console.log(`\n🤖 AI生成概率: ${probability}%`);
                } else {
                    console.log('\n❌ 检测失败');
                }
                
            } else {
                console.log(`
增强版AI内容检测器 - 使用方法:

  node ai_content_detector_enhanced.js [选项] <文本或文件>

选项:
  --mode <mode>        设置检测模式: bitbrowser | proxy | hybrid (默认: hybrid)
  --file <path>        检测指定文件
  --batch <dir>        批量检测目录中的所有.md文件

示例:
  node ai_content_detector_enhanced.js "这是要检测的文本"
  node ai_content_detector_enhanced.js --mode bitbrowser "测试文本"
  node ai_content_detector_enhanced.js --file article.md
  node ai_content_detector_enhanced.js --batch golf_content/2025-08-14/

说明:
  - hybrid模式: 优先使用比特浏览器，失败时降级到代理
  - bitbrowser模式: 仅使用比特浏览器
  - proxy模式: 仅使用智能代理
                `);
            }
            
        } catch (error) {
            console.error('执行失败:', error);
        } finally {
            await detector.cleanup();
        }
    })();
}